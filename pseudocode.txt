Graph in adjacency list

BFS(Graph, start)
    for each vertex_u in Graph
        vertex_u.state = undiscovered
        vertex_u.distance = infinite
        vertex_u.parent = NULL

    start.state = discovered
    start.distance = 0
    start.parent = NULL

    queue = {}
    queue.push(start)

    while queue not empty
        vertex_u = queue.pop()
        for each vertex_v in vertex_u.adjacency
            if vertex_v.state == undiscovered
                vertex_v.state = discovered
                vertex_v.distance = vertex_u.distance + 1
                vertex_v.parent = vertex_u
                queue.push(vertex_v)

            vertex_u.state = expanded

BFS_with_tickets(Graph, start, ticket_list)
    for each vertex_u in Graph
        vertex_u.state = undiscovered
        vertex_u.parent = NULL

    start.state = discovered
    start.parent = NULL
    start.ticket_list = ticket_list

    queue = {}
    queue.push(start)

    while queue not empty
        parent_node = queue.pop()

        for each next_vertex in parent_node.adjacency_list
            child_node = graph.get_node(next_vertex)

            if not graph.enough_tickets(parent_node, next_vertex)
                continue
            
            else if child_node.state == undiscovered
                child_node.state = discovered
                child_node.parent = parent_node
                child_node.ticket_list = graph.take_ticket(parent_node, child_node, next_vertex)
                queue.push(child_node)

            parent_node.state = expanded


THREEFS(graph_list, start_list, end_list)
    result_list = []
    for each graph, start, end in graph_list, start_list, end_list
        result = bfs(graph_list, graph, start, end)
        result_list.append(result)

    return result_list


bfs(graph_list, graph, start, end)
    queue = []
    queue.append(start)

    while queue not empty
        parent_node = queue.pop()

        for each next_vertex in parent_node.adjacency_list
            child_node = graph.get_node(next_vertex)

            if not graph.enough_tickets(parent_node, next_vertex)
                    or taken_spot(graph_list, current_graph, current_distance, next_vertex)
                continue
            
            else if child_node.state == undiscovered
                child_node.state = discovered
                child_node.parent = parent_node
                child_node.distance = current_distance + 1
                queue.push(child_node)

    return Find-Path(graph, start, end)

taken_spot(graph_list, current_graph, current_distance, next_vertex)
    for each graph in graph_list
        if graph == current_graph
            continue

        node = graph.get_node(next_vertex)
        if node.state == taken and node.distance == current_distance
            return true

    return false

init_bfs(graph_list, start_list)
    queue_list = {}
    for each graph in graph_list
        for each vertex_u in graph
        vertex_u.state = undiscovered
        vertex_u.parent = NULL
        vertex_u.distance = NULL

    for each start in start_list
        start.state = discovered
        start.parent = NULL
        start.distance = 0
        queue = {}
        queue.push(start)
        queue_list.push(queue)

    return queue_list


Find-Path(Graph, start, end) 
// Finds the shortest path recursively after the BFS

    if start.position == end.position
        start.state = taken
        return start

    else if end.parent == NULL
        return ERROR

    else
        end.state = taken
        return Find-Path(Graph, start, end.parent) + end