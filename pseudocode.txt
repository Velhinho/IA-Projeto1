Graph in adjacency list

BFS(Graph, start)
    for each vertex_u in Graph
        vertex_u.state = undiscovered
        vertex_u.distance = infinite
        vertex_u.parent = NULL

    start.state = discovered
    start.distance = 0
    start.parent = NULL

    queue = {}
    queue.push(start)

    while queue not empty
        vertex_u = queue.pop()
        for each vertex_v in vertex_u.adjacency
            if vertex_v.state == undiscovered
                vertex_v.state = discovered
                vertex_v.distance = vertex_u.distance + 1
                vertex_v.parent = vertex_u
                queue.push(vertex_v)

            vertex_u.state = expanded

BFS_with_tickets(Graph, start, ticket_list)
    for each vertex_u in Graph
        vertex_u.state = undiscovered
        vertex_u.parent = NULL

    start.state = discovered
    start.parent = NULL
    start.ticket_list = ticket_list

    queue = {}
    queue.push(start)

    while queue not empty
        parent_node = queue.pop()

        for each next_vertex in parent_node.adjacency_list
            child_node = graph.get_node(next_vertex)

            if not graph.enough_tickets(parent_node, next_vertex)
                continue
            
            else if child_node.state == undiscovered
                child_node.state = discovered
                child_node.parent = parent_node
                child_node.ticket_list = graph.take_ticket(parent_node, child_node, next_vertex)
                queue.push(child_node)

            parent_node.state = expanded


Find-Path(Graph, start, end) 
// Finds the shortest path recursively after the BFS

    if start.position == end.position
        return start

    else if end.parent == NULL
        return ERROR

    else
        return Find-Path(Graph, start, end.parent) + end